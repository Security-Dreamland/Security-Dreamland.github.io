---
title: 汉诺塔问题
time: 2016.03.13 10:30:00
layout: post
tags:
- 算法
- C++
excerpt: 汉诺塔问题解析
    
---
#汉诺塔问题

## 简介
汉诺塔是根据一个传说形成的数学问题：

有三根杆子A，B，C。A杆上有N个(N>1)穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆：

- 每次只能移动一个圆盘；
- 大盘不能叠在小盘上面。

提示：可将圆盘临时置于B杆，也可将从A杆移出的圆盘重新移回A杆，但都必须遵循上述两条规则。

问：如何移？最少要移动多少次？

##解法
解法的基本思想是递归。假设有A、B、C三个塔，A塔有N块盘，目标是把这些盘全部移到C塔。那么先把A塔顶部的N-1块盘移动到B塔，再把A塔剩下的大盘移到C，最后把B塔的N-1块盘移到C。

每次移动多于一块盘时，则再次使用上述算法来移动。

## 递归代码
```
//
//  main.cpp
//  hannoi
//
//  Created by moxiaoxi on 16/3/12.
//  Copyright © 2016年 moxiaoxi. All rights reserved.
//
using namespace std;
#include <iostream>

//先将A杆上n－1移动到B杆上，再将最大盘的移动到C杆，然后，将B杆上n－1移动到C杆（A－>B,B->C移动需要借助第三块板）

void hannoi(int n, char from,char buffer,char dest)
{
    if(n==1)
        cout<<"从"<<from<<"移动"<<n<<"号圆盘，到"<<dest;
    else
    {
        hannoi(n-1,from,dest,buffer);//通过C，将A上的n－1块移动到B上
        cout<<"从"<<from<<"移动"<<n<<"号圆盘，到"<<dest;
        hannoi(n-1, buffer, from, dest);
    }
    return;
    
}

int main() {
    unsigned n;
    cin>>n;
    hannoi( n,'A','B','C');
    return 0;
}
```

----
## 非递归代码
使用栈，压栈的顺序和递归代码顺序有出入！务必注意！

```
using namespace std;
#include <iostream>
struct han
{
    int begin,end;
    char from,buffer,dest;
    han(){};
    han(int begin,int end,char from,char buffer,char dest):begin(begin),end(end),from(from),buffer(buffer),dest(dest){};
};
    
void hannoi(int n, char from,char buffer, char dest)
{
    stack<han> stk;
    han temp;
    stk.push(han(1,n,from,buffer,dest));
    while(!stk.empty()){
        temp=stk.top();
        stk.pop();
        if( temp.begin ==temp.end)
            cout<<"从"<<temp.from<<"移动"<<temp.begin<<"号圆盘，到"<<temp.dest<<endl;
        else
        {
            stk.push(han(temp.begin,temp.end-1,temp.buffer,temp.from,temp.dest));
            stk.push(han(temp.end,temp.end,temp.from,temp.buffer,temp.dest));
            stk.push(han(temp.begin,temp.end-1,temp.from,temp.dest,temp.buffer));
        }
    }
}


int main() {
    unsigned n;
    cin>>n;
    hannoi( n,'A','B','C');
    return 0;

}
```