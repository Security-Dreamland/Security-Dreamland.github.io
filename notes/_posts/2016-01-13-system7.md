---
layout: post
category: note
title: 操作系统概念阅读笔记7
subtitle: 死锁
excerpt: 系统模型 必要条件 死锁处理方法 死锁避免 
first_time: 2016.01.13 15:31:00
time: 2016.01.13 21:03:09
tags:
- 操作系统
- 死锁

---


#死锁
在多道程序环境下，多个进程可能竞争一定数量的资源。而当某个进程申请资源时，而如果这是该资源不可用，那么该进程便进入等待状态。而如果所申请的资源是被其他等待进程占有，那么该等待进程有可能再也无法改变其状态。这种状况就叫做死锁。即在无外力作用下，两个互相等待的进程将永远无法执行完成，只能保持互相等待的状态。


----
##系统模型
1. 资源：资源可分为多种类型，每种类型具有一定数量的实例。比如，内存空间、cpu周期、文件、I/O设备（打印机或DVD驱动器）
2. 使用模型：“申请--分配--使用--释放”模式 
	
	进程在使用资源前必须申请资源，在使用完毕前必须释放资源。申请不被允许（申请的资源被其他进程所使用）时，申请进程必须等待，直到它获得该资源位置。

---
##必要条件
1. **互斥：至少有一种资源必须处于非共享模式。**即一个资源在被一个进程使用时，另一个进程是无法使用该资源的。除非正在使用的进程执行完毕，释放了该资源。
2. **占有并等待	：一个进程必须占有至少一个资源，并等待一被另外进程资源占有的资源。**
3. **非抢占：资源不能被抢占**
4. **循环等待：在资源分配图中，存在环。**比如，P0等待P1占有的资源，P1等待P2占有的资源，而且P2等待P0占有的资源。

----
##死锁处理方法
1. 使用协议来预防或避免死锁
2. 忽略死锁，再通过周期检测。检测到死锁，对此加以恢复。
3. 忽略死锁问题，认为死锁不会发生。（让程序开发者，写程序时，自己处理，保证不会有死锁产生）

###死锁预防
死锁预防是一组方法，以确保至少一个必要条件不成立。（缺点：导致低设备利用率和系统吞吐率)
1. 破坏“互斥” 
	保证所有资源都是共享资源。比如 多次读取文件
2. 破坏“占有并等待”：
	1. 要求每个进程在运行前必须一次性申请它所要求的所有资源，且仅当该进程所要资源均可满足时才给予一次性分配。 
	2. 允许进程在没有资源时，才可申请资源。
3. 破坏“非抢占”
 	在允许进程动态申请资源前提下规定，一个进程在申请新的资源不能立即得到满足而变为等待状态之前，必须隐式释放已占有的全部资源，若需要再重新申请 
 	
4. 破坏“循环等待”条件 
	
	采用资源有序分配法： 
	把系统中所有资源编号，进程在申请资源时必须严格按资源编号的递增次序进行，否则操作系统不予分配。 


###死锁避免
通过一些额外的信息，来衡量某些进程申请的资源是否分配。
	
####安全状态####
（概念补充）：
	- 存在一个安全的序列，使进程能按该序列不死锁的运行，则说明系统处于安全状态。
	- 安全状态不是死锁状态。相反，死锁状态是不安全状态。然而，不适合所欲不安全状态都能导致死锁状态。不安全状态，主要表明的是 操作系统不能阻止进程以会导致死锁的方式申请资源。关系图，如图所示：
	![](http://i.imgur.com/piMWby3.png)
	
1. **资源分配图算法**
	
	针对的是每种资源只有一个实例的情况。其主要就是保证在资源分配图中不存在环即可。
2. **银行家算法** 
	针对的是每种资源类型有多个实例的资源分配系统。这个具体细节 下篇博文发^v^.


###死锁检测
通过一个算法周期检测当前状态下是否存在死锁。若有，则纠正死锁状态。
1.**每种资源只有单个实例情况** 从资源分配图中，删除所有资源类型节点，合并适当边，就可以得到等待图。如图所示：
![](http://i.imgur.com/MpZn1vD.png)
接下来只需要维护等待图，保证其不出现环即可。（若出现，则通过一定策略，消去）

###死锁恢复
####1.进程终止

1. 终止所有死锁进程
2. 一次终止一个进程直到取消死锁循环为止。 （最好选择一个“代价最小”的进程先终止）

####2.资源抢占
通过资源抢占来取消死锁，逐步从进程中抢占资源给其他进程使用，直到死锁环被打破为止。
问题：

1. 如何选择牺牲品（代价最小）
2. 如何回滚：即执行完毕后，必须将进程回滚到某个安全状态，以便从该状态重启进程。
3. 如何确保不会发生饥饿