---


title: C++复习

time: 2016.08.28 15:22:00

layout: post

tags:

- Coding
- C++

excerpt: 最近需要准备一些计算机的机试环节，在这复习下C++的一些东西。

---


# C++复习

## 类

1. 一个派生类可以同时有多个基类，这种情况称为多重继承，派生类只有一个基类，称为单继承。直接派生，间接派生。

2. 继承方式规定了如何访问基类继承的成员。继承方式有public, private, protected。如果不显示给出继承方式，默认为private继承。继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限。
3. 派生类继承基类中除构造和析构函数以外的所有成员。
4. 公有继承：当类的继承方式为公有继承时，基类的公有和保护成员的访问属性在派生类中不变，而基类的私有成员不可访问。即基类的公有成员和保护成员被继承到派生类中仍作为派生类的公有成员和保护成员。派生类的其他成员可以直接访问它们。无论派生类的成员还是派生类的对象都无法访问基类的私有成员。
5. 私有继承:当类的继承方式为私有继承时，基类中的公有成员和保护成员都以私有成员身份出现在派生类中，而基类的私有成员在派生类中不可访问。基类的公有成员和保护成员被继承后作为派生类的私有成员，派生类的其他成员可以直接访问它们，但是在类外部通过派生类的对象无法访问。无论是派生类的成员还是通过派生类的对象，都无法访问从基类继承的私有成员。通过多次私有继承后，对于基类的成员都会成为不可访问。因此私有继承比较少用。
6. 保护继承:保护继承中，基类的公有成员和私有成员都以保护成员的身份出现在派生类中，而基类的私有成员不可访问。派生类的其他成员可以直接访问从基类继承来的公有和保护成员，但是类外部通过派生类的对象无法访问它们，无论派生类的成员还是派生类的对象，都无法访问基类的私有成员。
7. 派生类中从基类继承而来的成员的初始化工作是由基类的构造函数完成，然后派生类中新增的成员在派生类中的构造函数中初始化。顺序如下： 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左到右）；
   调用内嵌成员对象的构造函数，调用顺序按照它们在类中声明的顺序；
   派生类的构造函数体中的内容。
8. 如果基类中没有不带参数的构造函数，那么在派生类的构造函数中必须调用基类构造函数，以初始化基类成员。
9. 派生类的析构函数的功能是在该对象消亡之前进行一些必要的清理工作，析构函数没有类型，也没有参数。析构函数的执行顺序与构造函数相反。
10. 虚基类是用来解决继承过程中的重名、多重拷贝问题。将共同基类设置为虚基类，这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数也只有一个映射。
11. 一般而言，派生类只对其直接基类的构造函数传递参数，但是在虚基类中，不管是直接或间接虚基类的所有派生类，都必须在构造函数的成员初始化列表中列出对虚基类的初始化。
12. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” virtual void funtion()=0
13. 1、多态性

	- 指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。

		- a、编译时多态性：通过重载函数实现

		- b、运行时多态性：通过虚函数实现。

14. 2、虚函数

	虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态覆盖（Override）

15. 抽象类

	包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。
	
	
-----

## 一些技巧

### 动态开辟数组

#### 1. 一维数组

	int n=50;
	int *array = new int[n]{0};
	delete [] array

#### 2. 二维数组

	int n =50;//生成n＊n
	int **array = new int *[n]{0};
	for(int i =0 ;i<n;i++){
		array[i]=new int [n]
	}
	for(int i =0 ;i<n;i++){
		delete [] array[i];
	}
	delete [] array;



### 文件读取（便于测试）

#### 1. 读取
 	
 	int score;
 	char name[80]
 	ifstream infile;
 	infile.open("input.txt");
 	infile>>score>>name; 
 	cout<<score<<' '<<name<<endl;
 	infile.close();
 
#### 2. 写入
	
	int score=8;
	char name[80]="hello";
 	ofstream outfile;
 	outfile.open("output.txt");
 	outfile<<name<<' '<<score<<endl;
 	outfile.close();
 
###  cin/cout的格式控制

头文件#include<iomanip>

1. setw(width)设置域宽
	- setw()控制符只对其后输出的第一个数据有效，其他控制符则对其后的所有输入输出产生影响。
	- 默认为setw(0),按实际输出。
	- 如果输出的数值占用的宽度超过setw(int n)设置的宽度，则按实际宽度输出
	
			Eg:   cout<<setw(5)<<'a'<<'b'<<endl;  
			输出:    ab
			float f=0.12345;　
			cout<<setw(3)<<f<<endl;   
			输出为0.12345

2. setfill(c)
	- 设置填充字符，即"<<"符号后面的数据长度小于域宽时，使用什么字符进行填充。

		```Eg:   cout<<setfill('*')<<setw(5)<<'a'<<endl;   输出:****a```

3. setprecision(int n)
	
	可以控制显示浮点数的有效位
	n 代表数字总位数
	
4.  showpoint　将浮点数以带小数点、带结尾0 的形式输出，即便它没有小数部分
		
		Eg: 
		float f1 = 13;
		float f2 = 3.1415926;
		float f3 = 5;
		cout << showpoint << f1 << endl;
		cout << showpoint << f2 << " " << f3 <<endl;
		输出：13.0000
		     3.14159 
		     5.00000

5. left  输出内容左对齐 right 输出内容右对齐

		cout << setw(5) << 13 << endl;
		cout << setw(5) << right << 13 << endl;
		cout << setw(5) << left << 13 << endl;
		输出：    13
		　　　　  13（和上面一样的）
		　   13  


-----
## algorithm 库

### sort函数 	

1. sort函数默认为升序排序，调用方法为sort(a,a+n)或sort(a.begin(),a.end()) 前者针对数组，后者针对容器。

2. 需要快读实现降序时，有三种方法
	1. 反转升序数组（reserve函数）
	2. 反向迭代sort(a.rend(),a.rbegin())
	3. 自己定义比较函数（非常推荐这个，可以完成定制化操作）
3. 对于String，其可以如同数组一样使用，但不能利用C字符串函数，可使用C++标准库字符串函数。

4. 官方自带了几个比较函数
	equal_to	相等
	not_equal_to	不相等
	less	小于
	greater	大于
	less_equal	小于等于
	greater_equal	大于等于

下面给出自定义比较函数的示范：

	struct node{
    	int x;
    	int y;
	};
	bool compare(node a, node b){
    	return a.x>b.x;
	}
	int main(int argc, const char * argv[]) {
    	vector<node> TestMap;
    	node temp;
    	int n,m,flag;
    	while (cin>>n>>m) {
        	if (n==0&&m==0) {
            	break;
        	}
        	flag=-1;
        	for (int i=0; i<TestMap.size(); i++) {
            	if (TestMap[i].x==n) {
                	flag=i;
            	}
        	}
        	if (flag==-1) {
            	temp.x=n;
            	temp.y=m;
            	TestMap.push_back(temp);
        	}else{
            	TestMap[flag].y+=m;
        	}
    	}
    	while (cin>>n>>m) {
        	if (n==0&&m==0) {
            	break;
        	}
        	flag=-1;
        	for (int i=0; i<TestMap.size(); i++) {
            	if (TestMap[i].x==n) {
                	flag=i;
            	}
        	}
        	if (flag==-1) {
            	temp.x=n;
            	temp.y=m;
            	TestMap.push_back(temp);
        	}else{
            	TestMap[flag].y+=m;
        	}
    	}
    	sort(TestMap.begin(), TestMap.end(),compare);
    	for (int i =0; i<TestMap.size(); i++) {
        	cout<<TestMap[i].x<<' '<<TestMap[i].y<<endl;
    	}
    	return 0;
	}

 	
----

## 	容器

### deque

### list

### map

### multimap

### set

### multiset

### stack

### queue

### pririty_queue

### vector

## 其他

1. 标准库的头文件用尖括号<>括起来，非标准库的头文件用双引号“”括起来。